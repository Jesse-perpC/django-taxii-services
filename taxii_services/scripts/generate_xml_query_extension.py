# Copyright (c) 2014, The MITRE Corporation. All rights reserved.
# For license information, see the LICENSE.txt file

from __future__ import absolute_import

import argparse
import json

from lxml import etree

_STD_INDENT = '  '


def pretty_format(d, indent=''):
    """
    Pretty prints a dictionary.
    """

    str_ = "{\n"
    for k, v in d.iteritems():
        if isinstance(v, dict):
            if len(v) == 0:
                str_ += indent + _STD_INDENT + "'%s': {}, \n" % k
            else:
                str_ += indent + _STD_INDENT + "'%s': " % k
                str_ += pretty_format(v, indent + _STD_INDENT)
        else:
            v_ = v
            if not isinstance(v, bool):
                v_ = "'%s'" % v
            str_ += indent + _STD_INDENT + "'%s': ""%s,\n" % (k, v_)
    str_ += indent + "}, \n"
    return str_


def split_tag(tag):
    if '}' in tag:
        parts = tag[1:].split('}')
        namespace = parts[0]
        name = parts[1]
    else:
        namespace = None
        name = tag

    return name, namespace

# data is a dict that stores ALL THE INFOS
# Each item is basically this:
# {'<non-namespaced element name>':
#          {
#              'children': None or dict of children,
#              'has_text': True or False (if the element can have text data)
#              'ns': '<the_namespace>'
#          }
# }
# Then ... the trick is to turn this into code!

# TODO: This script writes 'None' instead of None

def add_element_to_dict(elem, d):
    name, namespace = split_tag(elem.tag)
    print 'looking at ', name
    if not d.get(name, None):
        d[name] = {}
        d[name]['has_text'] = False
        d[name]['namespace'] = namespace
        d[name]['prefix'] = elem.prefix
        d[name]['children'] = {}

    if elem.text and elem.text.strip() != '':
        d[name]['has_text'] = True

    # Add the attributes as children
    for attribute in elem.keys():
        print '  looking at ', attribute
        attr_name, attr_namespace = split_tag(attribute)
        has_text = True
        children = {}
        attr_prefix = None
        if attr_namespace:  # Look up the prefix in a horribly inefficient manner...
            for k, v in elem.nsmap.iteritems():
                if v == attr_namespace:
                    attr_prefix = k
                    break

        d[name]['children']['@' + attr_name] = {'has_text': True,
                                                'namespace': attr_namespace,
                                                'prefix': attr_prefix,
                                                'children': children}

    # Add the element children as children
    for child in elem.iterchildren(tag=etree.Element):
        if child is None:
            continue
        add_element_to_dict(child, d[name]['children'])


def create_query_handler(name, data, tev):
    outfile = name + '.py'
    f = open(outfile, 'w')
    f.write("""
# BaseXMLQueryHandler extension generated by generate_xml_query_extension.py

from taxii_services.base_taxii_handlers import BaseXmlQueryHandler
from taxii_services.management import register_query_handler

class %s(BaseXmlQueryHandler):
    \"\"\"
    BaseXmlQueryHandler extension generated by generate_xml_query_extension.py
    \"\"\"
    supported_targeting_expression = %s
    mapping_dict = \\
%s

register_query_handler(%s, name="%s")
""" % (name, tev, pretty_format(data)[:-1], name, name))
    f.flush()
    f.close()


def main():
    parser = argparse.ArgumentParser(description='XML Query Extension Generator')
    parser.add_argument('--infile', dest='infile', required=True, help="The sample XML file to use for generating the BaseXmlQueryHandler extension.")
    parser.add_argument('--tev', dest='tev', required=True, help="The targeting expression vocabulary this extension supports.")
    parser.add_argument('--name', dest='name', required=True, help="The name of the BaseXmlQueryHandler extension. Will be used for the output filename and class name.")
    args = parser.parse_args()

    root = etree.parse(args.infile).getroot()
    data = {'root_context': {'children': {}}}
    add_element_to_dict(root, data['root_context']['children'])

    create_query_handler(args.name, data, args.tev)

    print "Extension created in %s" % (args.name + '.py', )

if __name__ == "__main__":
    main()
